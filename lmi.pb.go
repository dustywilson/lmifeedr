// Code generated by protoc-gen-go.
// source: lmi.proto
// DO NOT EDIT!

/*
Package lmifeedr is a generated protocol buffer package.

It is generated from these files:
	lmi.proto

It has these top-level messages:
	Computer
	ComputerRequest
	WatchRequest
*/
package lmifeedr

import proto "github.com/golang/protobuf/proto"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal

type Computer struct {
	HostID    uint64 `protobuf:"varint,1,opt,name=hostID" json:"hostID,omitempty"`
	OldHostID uint64 `protobuf:"varint,11,opt,name=old_hostID" json:"old_hostID,omitempty"`
	Name      string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	OldName   string `protobuf:"bytes,12,opt,name=old_name" json:"old_name,omitempty"`
	Ip        string `protobuf:"bytes,3,opt,name=ip" json:"ip,omitempty"`
	OldIp     string `protobuf:"bytes,13,opt,name=old_ip" json:"old_ip,omitempty"`
	Status    int32  `protobuf:"varint,4,opt,name=status" json:"status,omitempty"`
	OldStatus int32  `protobuf:"varint,14,opt,name=old_status" json:"old_status,omitempty"`
	ChangeSet uint32 `protobuf:"varint,20,opt,name=change_set" json:"change_set,omitempty"`
}

func (m *Computer) Reset()         { *m = Computer{} }
func (m *Computer) String() string { return proto.CompactTextString(m) }
func (*Computer) ProtoMessage()    {}

type ComputerRequest struct {
	HostID    uint64 `protobuf:"varint,1,opt,name=hostID" json:"hostID,omitempty"`
	NameMatch string `protobuf:"bytes,2,opt,name=nameMatch" json:"nameMatch,omitempty"`
	IpMatch   string `protobuf:"bytes,3,opt,name=ipMatch" json:"ipMatch,omitempty"`
}

func (m *ComputerRequest) Reset()         { *m = ComputerRequest{} }
func (m *ComputerRequest) String() string { return proto.CompactTextString(m) }
func (*ComputerRequest) ProtoMessage()    {}

type WatchRequest struct {
	HostID    []uint64 `protobuf:"varint,1,rep,name=hostID" json:"hostID,omitempty"`
	NameMatch []string `protobuf:"bytes,2,rep,name=nameMatch" json:"nameMatch,omitempty"`
	IpMatch   []string `protobuf:"bytes,3,rep,name=ipMatch" json:"ipMatch,omitempty"`
}

func (m *WatchRequest) Reset()         { *m = WatchRequest{} }
func (m *WatchRequest) String() string { return proto.CompactTextString(m) }
func (*WatchRequest) ProtoMessage()    {}

// Client API for LMIFeedr service

type LMIFeedrClient interface {
	GetComputer(ctx context.Context, in *ComputerRequest, opts ...grpc.CallOption) (*Computer, error)
	GetComputers(ctx context.Context, in *ComputerRequest, opts ...grpc.CallOption) (LMIFeedr_GetComputersClient, error)
	Watch(ctx context.Context, in *WatchRequest, opts ...grpc.CallOption) (LMIFeedr_WatchClient, error)
}

type lMIFeedrClient struct {
	cc *grpc.ClientConn
}

func NewLMIFeedrClient(cc *grpc.ClientConn) LMIFeedrClient {
	return &lMIFeedrClient{cc}
}

func (c *lMIFeedrClient) GetComputer(ctx context.Context, in *ComputerRequest, opts ...grpc.CallOption) (*Computer, error) {
	out := new(Computer)
	err := grpc.Invoke(ctx, "/lmifeedr.LMIFeedr/GetComputer", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lMIFeedrClient) GetComputers(ctx context.Context, in *ComputerRequest, opts ...grpc.CallOption) (LMIFeedr_GetComputersClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_LMIFeedr_serviceDesc.Streams[0], c.cc, "/lmifeedr.LMIFeedr/GetComputers", opts...)
	if err != nil {
		return nil, err
	}
	x := &lMIFeedrGetComputersClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type LMIFeedr_GetComputersClient interface {
	Recv() (*Computer, error)
	grpc.ClientStream
}

type lMIFeedrGetComputersClient struct {
	grpc.ClientStream
}

func (x *lMIFeedrGetComputersClient) Recv() (*Computer, error) {
	m := new(Computer)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *lMIFeedrClient) Watch(ctx context.Context, in *WatchRequest, opts ...grpc.CallOption) (LMIFeedr_WatchClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_LMIFeedr_serviceDesc.Streams[1], c.cc, "/lmifeedr.LMIFeedr/Watch", opts...)
	if err != nil {
		return nil, err
	}
	x := &lMIFeedrWatchClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type LMIFeedr_WatchClient interface {
	Recv() (*Computer, error)
	grpc.ClientStream
}

type lMIFeedrWatchClient struct {
	grpc.ClientStream
}

func (x *lMIFeedrWatchClient) Recv() (*Computer, error) {
	m := new(Computer)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for LMIFeedr service

type LMIFeedrServer interface {
	GetComputer(context.Context, *ComputerRequest) (*Computer, error)
	GetComputers(*ComputerRequest, LMIFeedr_GetComputersServer) error
	Watch(*WatchRequest, LMIFeedr_WatchServer) error
}

func RegisterLMIFeedrServer(s *grpc.Server, srv LMIFeedrServer) {
	s.RegisterService(&_LMIFeedr_serviceDesc, srv)
}

func _LMIFeedr_GetComputer_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(ComputerRequest)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(LMIFeedrServer).GetComputer(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _LMIFeedr_GetComputers_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ComputerRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LMIFeedrServer).GetComputers(m, &lMIFeedrGetComputersServer{stream})
}

type LMIFeedr_GetComputersServer interface {
	Send(*Computer) error
	grpc.ServerStream
}

type lMIFeedrGetComputersServer struct {
	grpc.ServerStream
}

func (x *lMIFeedrGetComputersServer) Send(m *Computer) error {
	return x.ServerStream.SendMsg(m)
}

func _LMIFeedr_Watch_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WatchRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LMIFeedrServer).Watch(m, &lMIFeedrWatchServer{stream})
}

type LMIFeedr_WatchServer interface {
	Send(*Computer) error
	grpc.ServerStream
}

type lMIFeedrWatchServer struct {
	grpc.ServerStream
}

func (x *lMIFeedrWatchServer) Send(m *Computer) error {
	return x.ServerStream.SendMsg(m)
}

var _LMIFeedr_serviceDesc = grpc.ServiceDesc{
	ServiceName: "lmifeedr.LMIFeedr",
	HandlerType: (*LMIFeedrServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetComputer",
			Handler:    _LMIFeedr_GetComputer_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetComputers",
			Handler:       _LMIFeedr_GetComputers_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Watch",
			Handler:       _LMIFeedr_Watch_Handler,
			ServerStreams: true,
		},
	},
}
